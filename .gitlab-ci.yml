stages:
  - sync
  - build
  - push
  - deploy

default:
  tags:
    - thehivehook_go

.docker-login-script: &docker-login
  - docker login -u $CI_REGISTRY_USER -p $CI_JOB_TOKEN $CI_REGISTRY

.rule-readme-file: &rule-readme
  - if: $CI_COMMIT_REF_NAME == "master"
    changes:
      - README.md
    when: never

.rule-branch-only: &rule-branch-master
  - if: $CI_COMMIT_REF_NAME == "master"
    when: on_success

sync-file-job:
  stage: sync
  script:
    - 'curl -v --request PUT --header PRIVATE-TOKEN:$GCM_SYNC_FILES_TOKEN -F branch=master -F author_email=nobody@mail.org -F author_name=auto_sync -F commit_message=Update README.md -F content="< $CI_PROJECT_DIR/README.md" http://gitlab.cloud.gcm/api/v4/projects/726/repository/files/README.md'

build-job:
  stage: build
  rules:
    - *rule-readme
    - *rule-branch-master
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA --build-arg VERSION=$CI_COMMIT_SHORT_SHA .
    # удаляем промежуточный образ с меткой temporary
    - docker image prune -a --force --filter="label=temporary"
    - *docker-login
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA

push-latest:
  stage: push
  rules:
    - *rule-readme
    - *rule-branch-master
  script:
    # поскольку у нас нет гарантии, что это задание будет выполнено тем же пользователем, который
    # создавал изображение на предыдущем шаге, мы повторно загружаем его локально.
    - *docker-login
    - docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    # ставим тег "latest"
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:latest

deploy-prod:
  stage: deploy
  rules:
    - *rule-readme
    - *rule-branch-master
  script:
    - "curl -X POST --fail -F token=$GET_REGISTRIE_TOKEN -F ref=master http://gitlab.cloud.gcm/api/v4/projects/726/trigger/pipeline"
  environment: production
